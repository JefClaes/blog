+++
title = "Anonymous type equality follow-up: Equals()"
slug = "2011-04-24-anonymous-type-equality-follow-up-equals"
published = 2011-04-24T12:30:00+02:00
author = "Jef Claes"
tags = [ "CodeSnippets", ".NET",]
+++
After publishing [yesterday's post on anonymous type
equality](http://jclaes.blogspot.com/2011/04/anonymous-type-equality.html),
I received an interesting comment from a fellow redditor. He stated that
even if the sequence of the property assignment were the same, the
equality comparison would still return false, because the types
generated by the C\# compiler are reference types, making their
references being tested for equality and not their data.  
  
This is very true, unless the Equals() method is overridden. And this is
exactly what the compiler does for us when we define anonymous types.  
  
[![](/post/images/thumbnails/2011-04-24-anonymous-type-equality-follow-up-equals-anonymoustypeequals.PNG)](/post/images/2011-04-24-anonymous-type-equality-follow-up-equals-anonymoustypeequals.PNG)  
In the Equals() method the equality of each property is evaluated by
using a [generic
EqualityComparer](http://msdn.microsoft.com/en-us/library/ms132123.aspx).  
  
That explains this behaviour.  
  

       1:  var a = new { x = 1, y = 2 };

       2:  var b = new { y = 2, x = 1 };

       3:  var c = new { x = 1, y = 2 };

       4:  Â 

       5:  Console.WriteLine(a.Equals(b)); //Prints False

       6:  Console.WriteLine(a.Equals(c)); //Prints True
