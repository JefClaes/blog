+++
title = "Anonymous type equality follow-up: Equals()"
slug = "2011-04-24-anonymous-type-equality-follow-up-equals"
published = 2011-04-24T12:30:00+02:00
author = "Jef Claes"
tags = [ "code",]
url = "2011/04/anonymous-type-equality-follow-up.html"
+++
After publishing [yesterday's post on anonymous type
equality](https://jefclaes.be/2011/04/anonymous-type-equality.html),
I received an interesting comment. The comment stated that
even if the sequence of the property assignment were the same, the
equality comparison would still return false, because the types
generated by the C\# compiler are reference types, making their
references being tested for equality and not their data.  
  
This is very true, unless the `Equals()` method is overridden. And this is exactly what the compiler does for us when we define anonymous types.  
[![](/post/images/thumbnails/2011-04-24-anonymous-type-equality-follow-up-equals-anonymoustypeequals.PNG)](/post/images/2011-04-24-anonymous-type-equality-follow-up-equals-anonymoustypeequals.PNG)  
In the `Equals()` method the equality of each property is evaluated by
using a [generic EqualityComparer](http://msdn.microsoft.com/en-us/library/ms132123.aspx).  
  
That explains this behaviour.  
  
```csharp
var a = new { x = 1, y = 2 };
var b = new { y = 2, x = 1 };
var c = new { x = 1, y = 2 };

Console.WriteLine(a.Equals(b)); //False
Console.WriteLine(a.Equals(c)); //True
```