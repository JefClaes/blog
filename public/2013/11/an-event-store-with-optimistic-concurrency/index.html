<!DOCTYPE html>
<html>
<head><script src="/livereload.js?port=1313&mindelay=10&v=2" data-no-instant defer></script>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>An event store with optimistic concurrency - Jef Claes</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta itemprop="name" content="An event store with optimistic concurrency">
<meta itemprop="description" content="Like I mentioned last week - after only five posts on the subject - there still are a great deal of event sourcing nuances left to be discovered.
My current event store implementation only supports a single user. Due to an aggressive file lock, concurrently accessing an aggregate will throw an exception. Can we allow multiple users to write to and read from an event stream? Also, what can we do about users making changes to the same aggregate; can we somehow detect conflicts and avoid changes to be committed?">
<meta itemprop="datePublished" content="2013-11-10T18:25:00&#43;01:00" />
<meta itemprop="dateModified" content="2013-11-10T18:25:00&#43;01:00" />
<meta itemprop="wordCount" content="645">



<meta itemprop="keywords" content="CodeSnippets,database,.NET,DDD," /><meta property="og:title" content="An event store with optimistic concurrency" />
<meta property="og:description" content="Like I mentioned last week - after only five posts on the subject - there still are a great deal of event sourcing nuances left to be discovered.
My current event store implementation only supports a single user. Due to an aggressive file lock, concurrently accessing an aggregate will throw an exception. Can we allow multiple users to write to and read from an event stream? Also, what can we do about users making changes to the same aggregate; can we somehow detect conflicts and avoid changes to be committed?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/2013/11/an-event-store-with-optimistic-concurrency/" />
<meta property="article:published_time" content="2013-11-10T18:25:00+01:00" />
<meta property="article:modified_time" content="2013-11-10T18:25:00+01:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="An event store with optimistic concurrency"/>
<meta name="twitter:description" content="Like I mentioned last week - after only five posts on the subject - there still are a great deal of event sourcing nuances left to be discovered.
My current event store implementation only supports a single user. Due to an aggressive file lock, concurrently accessing an aggregate will throw an exception. Can we allow multiple users to write to and read from an event stream? Also, what can we do about users making changes to the same aggregate; can we somehow detect conflicts and avoid changes to be committed?"/>
<link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/main.css" />

        <link id="dark-scheme" rel="stylesheet" type="text/css" href="http://localhost:1313/css/dark.css" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
		<script src="http://localhost:1313/js/main.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	
		<div class="avatar">
			<a href="http://localhost:1313/">
				<img src="https://image.freepik.com/free-vector/young-man-head-with-beard-avatar-character_24877-36786.jpg" alt="Jef Claes" />
			</a>
		</div>
	
	<h1 class="site-title"><a href="http://localhost:1313/">Jef Claes</a></h1>
	<div class="site-description"><p>On software and life</p><nav class="nav social">
			<ul class="flat"><li><a href="https://github.com/jefclaes" title="Github"><i data-feather="github"></i></a></li><li><a href="/index.xml" title="RSS"><i data-feather="rss"></i></a></li></ul>
		</nav></div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/post">All posts</a>
			</li>
			
			<li>
				<a href="/about">About</a>
			</li>
			
			<li>
				<a href="/tags">Tags</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post">
			<div class="post-header">
				
					<div class="meta">
						<div class="date">
							<span class="day">10</span>
							<span class="rest">Nov 2013</span>
						</div>
					</div>
				
				<div class="matter">
					<h1 class="title">An event store with optimistic concurrency</h1>
				</div>
			</div>
					
			<div class="markdown">
				<p>Like I mentioned <a href="http://www.jefclaes.be/2013/11/event-source-all-things.html">last
week</a> -
after only five posts on the subject - there still are a great deal of
event sourcing nuances left to be discovered.</p>
<p><a href="http://www.jefclaes.be/2013/10/an-event-store.html">My current event store
implementation</a> only
supports a single user. Due to an aggressive file lock, concurrently
accessing an aggregate will throw an exception. Can we allow multiple
users to write to and read from an event stream? Also, what can we do
about users making changes to the same aggregate; can we somehow detect
conflicts and avoid changes to be committed?</p>
<p><strong>Multi-user</strong></p>
<p>In the current version, concurrently appending to or reading from an
aggregate&rsquo;s event stream will throw since the file will already be
locked.</p>
<pre><code>Parallel.For(0, 1000, (i) =&gt;
{    
    _eventStore.CreateOrAppend(aggregateId, new EventStream(new List&lt;IEvent&gt;() 
    { 
        new ConcurrencyTestEvent() 
    }));
    _eventStore.GetStream(aggregateId);    
});
</code></pre>
<p>The exception looks like this: &ldquo;System.IO.IOException: The process
cannot access the file
&lsquo;C:\EventStore\92f42a08-8583-4dcf-98a5-440b06f34719.txt&rsquo; because it is
being used by another process.&rdquo;</p>
<p>To prevent concurrent file access, we can lock code accessing the
aggregate&rsquo;s event stream. Instead of using a global lock, we maintain a
dictionary of lock objects; one lock object per aggregate.</p>
<pre><code>lock (Lock.For(aggregateId))
{
    using (var stream = new FileStream(
        path, FileMode.Append, FileAccess.Write, FileShare.Read))
    {
        // Access the aggregate's event stream
    }
}

public class Lock
{
    private static ConcurrentDictionary&lt;Guid, object&gt; _locks = 
        new ConcurrentDictionary&lt;Guid, object&gt;();

    public static object For(Guid aggregateId)
    {
        var aggregateLock = _locks.GetOrAdd(aggregateId, new object());

        return aggregateLock;
    }
}     
</code></pre>
<p><strong>Optimistic concurrency</strong><br>
**<br>
**Before committing changes, we want to verify that no other changes
have been committed in the meanwhile. These changes could have
influenced the behaviour of our aggregate significantly. Appending the
last changes without considering what might have happened in the
meanwhile might corrupt our aggregate&rsquo;s state.</p>
<p>One way to verify this is by using a number (or a timestamp - clocks,
bah) to keep track of an aggregate&rsquo;s version. It&rsquo;s up to the client to
tell us which version he expects when appending to a stream. To
accommodate for this, we need to change the contract of our event store.</p>
<pre><code>public interface IEventStore
{
    void Create(Guid aggregateId, EventStream eventStream);

    void Append(Guid aggregateId, EventStream eventStream, int expectedVersion);

    ReadEventStream GetStream(Guid aggregateId);
}
</code></pre>
<p>Clients now need to pass in the expected version when appending to a
stream. The result of reading a stream will include the current
version.</p>
<p>In the event store, we now store an index with every event.</p>
<p><a href="/post/images/2013-11-10-an-event-store-with-optimistic-concurrency-EventsWithIndex.PNG"><img src="/post/images/thumbnails/2013-11-10-an-event-store-with-optimistic-concurrency-EventsWithIndex.PNG" alt=""></a></p>
<p>If we append to an event stream, we will get the current version by
reading the highest index - storing this in aggregate meta data would be
faster for reading. If the current version doesn&rsquo;t match the expected
version, we throw an exception.</p>
<pre><code>var currentVersion = GetCurrentVersion(path);

if (currentVersion != expectedVersion)
    throw new OptimisticConcurrencyException(expectedVersion, currentVersion);

using (var stream = new FileStream(
    path, FileMode.Append, FileAccess.Write, FileShare.Read))
{
    using (var streamWriter = new StreamWriter(stream))
    {
        foreach (var @event in eventStream)
        {
            currentVersion++;

            streamWriter.WriteLine(new Record(
                aggregateId, @event, currentVersion).Serialized());
        }
    }
}
</code></pre>
<p>A test for that looks something like this.</p>
<pre><code>try
{
    GivenEventStore();
    GivenAggregateId();
    GivenEventStreamCreated();
    WhenAppendingTwoEventStreamsWithTheSameExpectedVersion();
}
catch (OptimisticConcurrencyException ocex) 
{
    _expectedConcurrencyException = ocex;
}

[TestMethod]
public void ThenTheConcurrencyExceptionHasANiceMessage()
{
    var expected = &quot;Version found: 3, expected: 1&quot;;
    var actual = _expectedConcurrencyException.Message

    Assert.AreEqual(expected, actual);
}
</code></pre>
<p>Reading the event stream doesn&rsquo;t change much; we now also read the
current version, and return it with the event stream.Â </p>
<pre><code>var lines = File.ReadAllLines(path);

if (lines.Any())
{
    var records = lines.Select(x =&gt; Record.Deserialize(x, _assembly));
    var currentVersion = records.Max(x =&gt; x.Version);
    var events = records.Select(x =&gt; x.Event).ToList();

    return new ReadEventStream(events, currentVersion);
}

return null; 
</code></pre>
<p>And that&rsquo;s one way to implement optimistic concurrency. The biggest
bottleneck in this approach is how we read the current version; having
to read all the events to find the current version isn&rsquo;t very
efficient.</p>
<p>Transactional behaviour is also missing. I&rsquo;ve been thinking about adding
a COMMIT flag after appending a set of events, and using that to resolve
corruption on reads, or is this fundamentally flawed?</p>

			</div>

			<div class="tags">
				
					
						<ul class="flat">
							
							<li><a href="/tags/codesnippets">CodeSnippets</a></li>
							
							<li><a href="/tags/database">database</a></li>
							
							<li><a href="/tags/.net">.NET</a></li>
							
							<li><a href="/tags/ddd">DDD</a></li>
							
						</ul>
					
				
			</div></div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div>2013  <a href="https://github.com/knadh/hugo-ink">Ink</a> theme on <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>

<script>feather.replace()</script>
</body>
</html>
