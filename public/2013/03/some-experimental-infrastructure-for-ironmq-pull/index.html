<!DOCTYPE html>
<html>
<head><script src="/livereload.js?port=1313&mindelay=10&v=2" data-no-instant defer></script>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Some experimental infrastructure for IronMQ pull  - Jef Claes</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta itemprop="name" content="Some experimental infrastructure for IronMQ pull ">
<meta itemprop="description" content="I wrote about using IronMQ as a cloud-based message queue last week. In that post I explained that you can go at using IronMQ in two ways; either you pull from the queue yourself, or you let IronMQ push messages from the queue to your HTTP endpoints. At first sight, the latter allows you to outsource more infrastructure to their side, but upon closer inspection it also introduces other concerns: security, local debugging and scalability.">
<meta itemprop="datePublished" content="2013-03-10T17:29:00&#43;01:00" />
<meta itemprop="dateModified" content="2013-03-10T17:29:00&#43;01:00" />
<meta itemprop="wordCount" content="1093">



<meta itemprop="keywords" content="Messaging,.NET,Architecture,HTTP," /><meta property="og:title" content="Some experimental infrastructure for IronMQ pull " />
<meta property="og:description" content="I wrote about using IronMQ as a cloud-based message queue last week. In that post I explained that you can go at using IronMQ in two ways; either you pull from the queue yourself, or you let IronMQ push messages from the queue to your HTTP endpoints. At first sight, the latter allows you to outsource more infrastructure to their side, but upon closer inspection it also introduces other concerns: security, local debugging and scalability." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/2013/03/some-experimental-infrastructure-for-ironmq-pull/" />
<meta property="article:published_time" content="2013-03-10T17:29:00+01:00" />
<meta property="article:modified_time" content="2013-03-10T17:29:00+01:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Some experimental infrastructure for IronMQ pull "/>
<meta name="twitter:description" content="I wrote about using IronMQ as a cloud-based message queue last week. In that post I explained that you can go at using IronMQ in two ways; either you pull from the queue yourself, or you let IronMQ push messages from the queue to your HTTP endpoints. At first sight, the latter allows you to outsource more infrastructure to their side, but upon closer inspection it also introduces other concerns: security, local debugging and scalability."/>
<link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/main.css" />

        <link id="dark-scheme" rel="stylesheet" type="text/css" href="http://localhost:1313/css/dark.css" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
		<script src="http://localhost:1313/js/main.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	
		<div class="avatar">
			<a href="http://localhost:1313/">
				<img src="https://image.freepik.com/free-vector/young-man-head-with-beard-avatar-character_24877-36786.jpg" alt="Jef Claes" />
			</a>
		</div>
	
	<h1 class="site-title"><a href="http://localhost:1313/">Jef Claes</a></h1>
	<div class="site-description"><p>On software and life</p><nav class="nav social">
			<ul class="flat"><li><a href="https://github.com/jefclaes" title="Github"><i data-feather="github"></i></a></li><li><a href="/index.xml" title="RSS"><i data-feather="rss"></i></a></li></ul>
		</nav></div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/post">All posts</a>
			</li>
			
			<li>
				<a href="/about">About</a>
			</li>
			
			<li>
				<a href="/tags">Tags</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post">
			<div class="post-header">
				
					<div class="meta">
						<div class="date">
							<span class="day">10</span>
							<span class="rest">Mar 2013</span>
						</div>
					</div>
				
				<div class="matter">
					<h1 class="title">Some experimental infrastructure for IronMQ pull </h1>
				</div>
			</div>
					
			<div class="markdown">
				<p>I wrote about using <a href="http://www.jefclaes.be/2013/03/first-ironmq-impressions.html">IronMQ as a cloud-based message
queue</a>
last week. In that post I explained that you can go at using IronMQ in
two ways; either you pull from the queue yourself, or you let IronMQ
push messages from the queue to your HTTP endpoints. At first sight, the
latter allows you to outsource more infrastructure to their side, but
upon closer inspection it  also introduces other concerns: security,
local debugging and scalability.</p>
<p>Out-of-the-box there is no infrastructure in the client libraries to
facilitate periodic pull - polling, that&rsquo;s why I took a stab at doing it
myself. It&rsquo;s still rough, not production tested, and hasn&rsquo;t considered a
bunch of niche scenarios, but it should give you an idea of the
direction it&rsquo;s going.</p>
<p>A high-level overview of the components looks like this.</p>
<p><a href="/post/images/2013-03-10-some-experimental-infrastructure-for-ironmq-pull-IronMQPoll.PNG"><img src="/post/images/thumbnails/2013-03-10-some-experimental-infrastructure-for-ironmq-pull-IronMQPoll.PNG" alt=""></a></p>
<p>A queue host hosts multiple queue consumers. Each queue consumer will
poll a queue for one type of message on a configurable interval, and
dispatch dequeued messages to relevant message handlers. After handling
the message, the message will be deleted from the queue. If something
happened to go wrong, the error handler for this type of message will be
invoked, and the message will automatically return to the queue.</p>
<p>I&rsquo;m going to look at each component, starting with the smallest, and
slowly assemble them into bigger components.</p>
<p>Each queue consumer can be configured independently. For now, only the
polling interval can be changed. By default it&rsquo;s one second, or 1000
milliseconds.</p>
<pre><code>public interface IQueueConsumerConfiguration&lt;T&gt;
{
    int PollingInterval { get; }
}

public class QueueConsumerConfiguration&lt;T&gt; : IQueueConsumerConfiguration&lt;T&gt;
{     
    public int PollingInterval
    {
        get { return 1000; }
    }       
}
</code></pre>
<p>A queue can push messages, get raw messages, and delete them. The
implementation makes use of the <a href="https://github.com/odeits/IronTools">OSS IronIO client
libraries</a>.</p>
<pre><code>public interface IQueue&lt;T&gt;
{
    bool TryGet(out Message message);

    void Delete(string messageId);

    void Push(T message);
}

public class Queue&lt;T&gt; : IQueue&lt;T&gt;
{
    private readonly IronIO.IronMQ _queue;

    public Queue(string projectId, string token)
    {
        Guard.ForEmptyString(projectId, &quot;projectId&quot;);
        Guard.ForEmptyString(token, &quot;token&quot;);

        var queueName = typeof(T).Name; 

        _queue = new IronMQ(queueName, projectId, token);
    }

    public bool TryGet(out Message message) 
    {
        message = _queue.Get();            

        return message != null;
    }

    public void Delete(string messageId)
    {
        Guard.ForNull(messageId, &quot;messageId&quot;);

        _queue.Delete(messageId);
    }
    
    public void Push(T message)
    {
        Guard.ForNull(message, &quot;message&quot;);

        _queue.Push(JsonConvert.SerializeObject(message));
    }
}
</code></pre>
<p>A message dispatcher dispatches messages to the relevant handlers.</p>
<pre><code>public interface IMessageDispatcher
{
    void Dispatch&lt;T&gt;(T message);
}

public class MessageDispatcher : IMessageDispatcher
{
    private readonly IKernel _kernel;

    public MessageDispatcher(IKernel kernel)
    {
        _kernel = kernel;            
    }

    public void Dispatch&lt;T&gt;(T message)
    {
        var handlers = _kernel.GetAll&lt;IMessageHandler&lt;T&gt;&gt;();
      
        foreach (var handler in handlers)
            handler.Handle(message);                        
    }
}
</code></pre>
<p>If something goes wrong pulling the message from the queue or handling
it, the error handler will be invoked passing in the exception and the
raw message. Since it&rsquo;s possible that something is wrong with the
message in itself, I pass in the raw message with the serialized message
and all its meta data like id, delay and expiration date.</p>
<pre><code>public interface IErrorHandler&lt;T&gt;
{
    void Handle(Exception exception, Message message);
}

public class ErrorHandler&lt;T&gt; : IErrorHandler&lt;T&gt;
{       
    public void Handle(Exception exception, Message message)
    {
        throw exception;
    }     
}
</code></pre>
<p>Putting all these components to work together, we end up with a queue
consumer. When a queue consumer is started, it instantiates a timer
which will try to get a raw message from the queue on each tick. If
there&rsquo;s a raw message, it will extract the body, deserialize it into the
message, dispatch it, and finally delete the raw message from the queue.
If something goes wrong here, the error handler will be invoked, and the
message will automatically return back to the queue.</p>
<pre><code>public interface IQueueConsumer&lt;T&gt; : IQueueConsumer where T : class
{
}

public interface IQueueConsumer : IDisposable
{
    void Start();
}

public class QueueConsumer&lt;T&gt; : IQueueConsumer&lt;T&gt; where T : class
{
    private readonly IQueue&lt;T&gt; _queue;
    private readonly IErrorHandler&lt;T&gt; _errorHandler;
    private readonly IQueueConsumerConfiguration&lt;T&gt; _queueConsumerConfiguration;
    private readonly IMessageDispatcher _messageDispatcher;
    private Timer _timer;        

    public QueueConsumer(
        IQueue&lt;T&gt; queue, 
        IErrorHandler&lt;T&gt; errorHandler,
        IQueueConsumerConfiguration&lt;T&gt; queueConsumerConfiguration,
        IMessageDispatcher messageDispatcher)
    {
        _queue = queue;
        _errorHandler = errorHandler;
        _queueConsumerConfiguration = queueConsumerConfiguration;
        _messageDispatcher = messageDispatcher;
    }    

    public void Start()
    {
        _timer = new Timer((x) =&gt;
        {
            var message = (Message)null;
            var messageBody = (T)null;

            try
            {
                if (!_queue.TryGet(out message))
                    return;

                messageBody = (T)JsonConvert.DeserializeObject(
                    message.Body, typeof(T));

                _messageDispatcher.Dispatch&lt;T&gt;(messageBody);

                _queue.Delete(message.Id);
            }
            catch (Exception ex)
            {
                _errorHandler.Handle(ex, message);
            }                
        }, null, 0, _queueConsumerConfiguration.PollingInterval);            
    }

    public void Dispose()
    {
        if (_timer == null)
            return;

        _timer.Dispose();
    }
}
</code></pre>
<p>Since we have multiple queues to pull from, we can use a queue host to
control multiple queue consumers at once. The queue host configuration
decides which queue consumer to instantiate and start.</p>
<pre><code>public class QueueHostConfiguration
{
    public QueueHostConfiguration(IEnumerable&lt;Type&gt; messageTypes)
    {
        Guard.ForNull(messageTypes, &quot;messageTypes&quot;);

        MessageTypes = messageTypes;
    }

    public IEnumerable&lt;Type&gt; MessageTypes { get; private set; }
}

public class QueueHost : IDisposable
{
    private readonly IKernel _kernel;
    private readonly QueueHostConfiguration _configuration;

    private readonly List&lt;IQueueConsumer&gt; _consumers;

    public QueueHost(IKernel kernel, QueueHostConfiguration configuration)
    {
        _kernel = kernel;
        _configuration = configuration;

        _consumers = new List&lt;IQueueConsumer&gt;();
    }

    public void Start()
    {
        foreach (var messageType in _configuration.MessageTypes)
        {
            var queueConsumerType = typeof(IQueueConsumer&lt;&gt;).MakeGenericType(messageType);
            var queueConsumer = (IQueueConsumer)_kernel.Get(queueConsumerType);

            _consumers.Add(queueConsumer);

            queueConsumer.Start();
        }
    }

    public void Dispose()
    {
        if (_consumers == null)
            return;

        foreach (var consumer in _consumers)
            consumer.Dispose();
    }
}
</code></pre>
<p>In your application, you&rsquo;ll end up doing something like this to start
the queue host. </p>
<pre><code>using (var host = new QueueHost(kernel, new QueueHostConfiguration(
    new[] { typeof(MyMessage) })))
{
    host.Start();

    Console.ReadLine();
}
</code></pre>
<p>All the components are glued together using Ninject and some
conventions. </p>
<pre><code>public class Bootstrapper
{
    public void Run(IKernel kernel)
    {
        kernel.Bind(x =&gt; x
          .FromThisAssembly()
          .SelectAllClasses()
          .InheritedFrom(typeof(IMessageHandler&lt;&gt;))
          .BindAllInterfaces());

        kernel.Bind&lt;Infrastructure.IMessageDispatcher&gt;()
            .To&lt;Infrastructure.MessageDispatcher&gt;()
            .InTransientScope();
        kernel.Bind(x =&gt; x
            .FromAssemblyContaining(typeof(IQueue&lt;&gt;))
            .SelectAllClasses()
            .InheritedFrom(typeof(IQueue&lt;&gt;))
            .BindAllInterfaces()
            .Configure(y =&gt;
            {
                y.WithConstructorArgument(&quot;projectId&quot;, z =&gt; { return &quot;your_project_id&quot;; });
                y.WithConstructorArgument(&quot;token&quot;, z =&gt; { return &quot;your_token&quot;; });
            }));
        kernel
            .Bind(typeof(Infrastructure.IQueueConsumer&lt;&gt;))
            .To(typeof(Infrastructure.QueueConsumer&lt;&gt;));
        kernel
            .Bind(typeof(Infrastructure.IQueueConsumerConfiguration&lt;&gt;))
            .To(typeof(Infrastructure.QueueConsumerConfiguration&lt;&gt;));
        kernel
            .Bind(typeof(Infrastructure.IErrorHandler&lt;&gt;))
            .To(typeof(MyErrorHandler&lt;&gt;));    
    }
}
</code></pre>
<p>This is what I got for now. Next step is to do some more serious
integration testing, and see what gives. There are two things I already
kind of expect to run into; the maximum number of concurrent
connections, and thread starvation (each timer tick starts a new
thread). Anything else I&rsquo;m going to run into?</p>
<p>The biggest disadvantage of opting for pull that is already obvious now,
is the possible number of wasted HTTP requests. You could increase the
polling interval, and thereby lower the number of requests, but this
would harm the throughput of message bursts. Something I&rsquo;m considering
right now, is introducing a smart polling algorithm. Another option that
will lower the number of requests, is to pull batches instead of single
messages from the queue. Implementing this one will be rather
straightforward, yet improve things considerably.</p>

			</div>

			<div class="tags">
				
					
						<ul class="flat">
							
							<li><a href="/tags/messaging">Messaging</a></li>
							
							<li><a href="/tags/.net">.NET</a></li>
							
							<li><a href="/tags/architecture">Architecture</a></li>
							
							<li><a href="/tags/http">HTTP</a></li>
							
						</ul>
					
				
			</div></div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div>2013  <a href="https://github.com/knadh/hugo-ink">Ink</a> theme on <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>

<script>feather.replace()</script>
</body>
</html>
