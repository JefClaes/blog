<!DOCTYPE html>
<html>
<head><script src="/livereload.js?port=1313&mindelay=10&v=2" data-no-instant defer></script>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Designing entities: immutability first - Jef Claes</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta itemprop="name" content="Designing entities: immutability first">
<meta itemprop="description" content="The first year I wrote software for a living I spent my days mostly writing forms over data applications; most of my efforts were wasted just trying to make things work using ASP.NET and the Webforms engine. It was only after a year and graduating from the School of Hard Knocks that I learned there is a lot more to building clean and maintainable software than knowing the ins&rsquo; and outs&rsquo; of a proprietary UI technology.">
<meta itemprop="datePublished" content="2013-04-07T17:35:00&#43;02:00" />
<meta itemprop="dateModified" content="2013-04-07T17:35:00&#43;02:00" />
<meta itemprop="wordCount" content="1555">



<meta itemprop="keywords" content=".NET,Refactoring,DDD,Ramblings," /><meta property="og:title" content="Designing entities: immutability first" />
<meta property="og:description" content="The first year I wrote software for a living I spent my days mostly writing forms over data applications; most of my efforts were wasted just trying to make things work using ASP.NET and the Webforms engine. It was only after a year and graduating from the School of Hard Knocks that I learned there is a lot more to building clean and maintainable software than knowing the ins&rsquo; and outs&rsquo; of a proprietary UI technology." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/2013/04/designing-entities-immutability-first/" />
<meta property="article:published_time" content="2013-04-07T17:35:00+02:00" />
<meta property="article:modified_time" content="2013-04-07T17:35:00+02:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Designing entities: immutability first"/>
<meta name="twitter:description" content="The first year I wrote software for a living I spent my days mostly writing forms over data applications; most of my efforts were wasted just trying to make things work using ASP.NET and the Webforms engine. It was only after a year and graduating from the School of Hard Knocks that I learned there is a lot more to building clean and maintainable software than knowing the ins&rsquo; and outs&rsquo; of a proprietary UI technology."/>
<link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/main.css" />

        <link id="dark-scheme" rel="stylesheet" type="text/css" href="http://localhost:1313/css/dark.css" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
		<script src="http://localhost:1313/js/main.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	
		<div class="avatar">
			<a href="http://localhost:1313/">
				<img src="https://image.freepik.com/free-vector/young-man-head-with-beard-avatar-character_24877-36786.jpg" alt="Jef Claes" />
			</a>
		</div>
	
	<h1 class="site-title"><a href="http://localhost:1313/">Jef Claes</a></h1>
	<div class="site-description"><p>On software and life</p><nav class="nav social">
			<ul class="flat"><li><a href="https://github.com/jefclaes" title="Github"><i data-feather="github"></i></a></li><li><a href="/index.xml" title="RSS"><i data-feather="rss"></i></a></li></ul>
		</nav></div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/post">All posts</a>
			</li>
			
			<li>
				<a href="/about">About</a>
			</li>
			
			<li>
				<a href="/tags">Tags</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post">
			<div class="post-header">
				
					<div class="meta">
						<div class="date">
							<span class="day">07</span>
							<span class="rest">Apr 2013</span>
						</div>
					</div>
				
				<div class="matter">
					<h1 class="title">Designing entities: immutability first</h1>
				</div>
			</div>
					
			<div class="markdown">
				<p>The first year I wrote software for a living I spent my days mostly
writing forms over data applications; most of my efforts were wasted
just trying to make things work using ASP.NET and the Webforms engine.
It was only after a year and graduating from the School of Hard Knocks
that I learned there is a lot more to building clean and maintainable
software than knowing the ins&rsquo; and outs&rsquo; of a proprietary UI
technology.</p>
<p>One of the habits I have adapted over time, is designing new entities as
immutable objects first, and to go from there. I believe this helps me
to make more deliberate design decisions, leading to better designs.</p>
<p>Allow me to demonstrate this using a customer entity - I know this is
cliché, but I have a hard time coming up with original examples.</p>
<p><strong>A constructor</strong></p>
<p>This one might sound rather obvious, but you would be surprised how many
classes don&rsquo;t have the decency of a simple constructor, especially since
C# introduced <a href="http://msdn.microsoft.com/en-us/library/vstudio/bb384062.aspx">object
initializers</a>.
While object initializers definitely look good, they make your code
harder to maintain; classes don&rsquo;t communicate what they need to get by,
nor do they get the opportunity to protect their invariants as early as
possible.</p>
<p>Like I said, I design my classes to be immutable from the start; after
initialization they can&rsquo;t be modified. I&rsquo;m not even exposing any state
for now.</p>
<pre><code>public class Customer
{
    public Customer(
        Guid id,
        string firstName,
        string lastName,
        string street,
        string city,
        string country,
        DateTime birthdate,
        decimal balance)
    {
        FirstName = firstName;
        LastName = lastName;
        Street = street;
        City = city;
        Country = country;
        BirthDate = birthdate;
        Balance = balance;
    }

    public Guid Id { get; private set; }

    private string FirstName { get; set; }

    private string LastName { get; set; }

    private string Street { get; set; }

    private string City { get; set; }

    private string Country { get; set; }

    private DateTime BirthDate { get; set; }

    private decimal Balance { get; set; }
}
</code></pre>
<p><strong>Comparing identities</strong><br>
**<br>
**An entity is always unique within a system; it has an identity. To
encapsulate comparing two entities, and to avoid repeating myself, I
always override the Equals and GetHashCode methods. We&rsquo;re not guided
into doing this by our object&rsquo;s immutability though, but by common
sense.</p>
<pre><code>public override bool Equals(object obj)
{
    if (obj == null || GetType() != obj.GetType())
        return false;            

    var other = obj as Customer;
       
    return Id == other.Id;
}

public override int GetHashCode()
{
    return this.Id.GetHashCode();
}
</code></pre>
<p><strong>Defaults</strong><br>
**<br>
**When a new customer is created, its balance is still empty. The
constructor is the perfect place to initialize this default.</p>
<pre><code>public Customer(
    Guid id,
    string firstName,
    string lastName,
    string street,
    string city,
    string country,
    DateTime birthdate)
{
    FirstName = firstName;
    LastName = lastName;
    Street = street;
    City = city;
    Country = country;
    BirthDate = birthdate;
    Balance = 0;
}
</code></pre>
<p><strong>Protecting invariants</strong><br>
**<br>
**The next thing I&rsquo;ll do is use the constructor to guard for arguments
that don&rsquo;t satisfy my objects invariants. This way we guarantee that the
object can never be initialized with an invalid state; avoiding a bunch
of trouble along the way.</p>
<p>We expect a customer to have a first name, last name, street, city and
country which isn&rsquo;t empty. We also expect its birth date not to be in
the future.</p>
<pre><code>public Customer(
    Guid id,
    string firstName,
    string lastName,
    string street,
    string city,
    string country,
    DateTime birthdate)
{
    Guard.ForNullOrEmpty(firstName, &quot;first name&quot;);
    Guard.ForNullOrEmpty(lastName, &quot;last name&quot;);
    Guard.ForNullOrEmpty(street, &quot;street&quot;);
    Guard.ForNullOrEmpty(city, &quot;city&quot;);
    Guard.ForNullOrEmpty(country, &quot;country&quot;);
    Guard.ForDatesInTheFuture(birthdate, &quot;birthdate&quot;);

    Id = id;
    FirstName = firstName;
    LastName = lastName;
    Street = street;
    City = city;
    Country = country;
    BirthDate = birthdate;            
    Balance = 0;
}

public class Guard
{
    public static void ForNullOrEmpty(string value, string desc)
    {
        if (string.IsNullOrEmpty(value))
            throw new NullReferenceException(desc);
    }

    public static void ForDateInTheFuture(DateTime value, string desc)
    {
        if (value &gt; DateTimeProvider.Now())
            throw new ArgumentException(
                string.Format(&quot;{0} can't be a date in the future.&quot;, desc))
    }
}
</code></pre>
<p><strong>Composition and extracting value objects</strong><br>
**<br>
**I&rsquo;m fairly confident that every self-respecting programmer is annoyed
by the fact that the obvious concepts name and address haven&rsquo;t been
extracted yet. Especially since that bloated constructor is all up in
your face. Let&rsquo;s go ahead and extract two value objects: name and
address.</p>
<pre><code>public class Customer
{
    public Customer(
        Guid id,
        Name name,
        Address address,
        DateTime birthdate)
    {
        Guard.ForNull(name, &quot;name&quot;);
        Guard.ForNull(address, &quot;address&quot;);
        Guard.ForDateInTheFuture(birthdate, &quot;birthdate&quot;);

        Id = id;
        Name = name;
        Address = address;
        Balance = 0;
    }

    public Guid Id { get; private set; }
    
    private Name Name { get; set; }

    private Address Address { get; set; }

    private DateTime BirthDate { get; set; }

    private decimal Balance { get; set; }
}

public class Name
{
    public Name(string first, string last)
    {
        Guard.ForNullOrEmpty(first, &quot;first name&quot;);
        Guard.ForNullOrEmpty(last, &quot;last name&quot;);

        First = first;
        Last = last;
    }

    private string First { get; set; }

    private string Last { get; set; }

    public string Full 
    {
        get
        {
            return string.Format(&quot;{0} {1}&quot;, First, Last);
        }
    }
    
    public override bool Equals(Object obj)
    {
        ...
    }
    
    public override int GetHashCode()
    {
        ...
    }
}

public class Address
{
    public Address(string street, string city, string country)
    {
        Guard.ForNullOrEmpty(street, &quot;street&quot;);
        Guard.ForNullOrEmpty(city, &quot;city&quot;);
        Guard.ForNullOrEmpty(country, &quot;country&quot;);

        Street = street;
        City = city;
        Country = country;
    }

    private string Street { get; set; }

    private string City { get; set; }

    private string Country { get; set; }
    
    public override bool Equals(Object obj)
    {
        ...
    }
    
    public override int GetHashCode()
    {
        ...
    }
}
</code></pre>
<p>There, that looks better.</p>
<p>**Tell, don&rsquo;t ask **<br>
**<br>
**In good OOP we tell objects what to do, we don&rsquo;t want to query an
object for its state and do something based on that; that would lead to
broken encapsulation and thereby more brittle code.</p>
<p>Since our immutable object isn&rsquo;t exposing any state yet, we are forced
to ask ourselves why we want to expose something. This way, disregarding
&ldquo;tell don&rsquo;t ask&rdquo; becomes a deliberate choice.</p>
<p>Let&rsquo;s say we want to decrease the balance, and throw an exception when
funds are insufficient. Instead of asking the customer instance and
acting on that..</p>
<pre><code>if (!customer.HasSufficientFunds())
    throw new InsufficientFundsException();
</code></pre>
<p>It&rsquo;s better to encapsulate data and behaviour, and tell it what to do
instead.</p>
<pre><code>public class Customer
{
    public Customer(
        Guid id,
        Name name,
        Address address,
        DateTime birthdate)
    {
        Guard.ForNull(name, &quot;name&quot;);
        Guard.ForNull(address, &quot;address&quot;);
        Guard.ForDateInTheFuture(birthdate, &quot;birthdate&quot;);

        Id = id;
        Name = name;
        Address = address;
        Balance = 0;
    }

    public Guid Id { get; private set; }
    
    private Name Name { get; set; }

    private Address Address { get; set; }

    private DateTime BirthDate { get; set; }

    private decimal Balance { get; set; }

    private bool HasSufficientFunds(decimal value) 
    {
        return Balance - value &gt;= 0;
    }

    public void DecreaseBalance(decimal value)
    {
        if (HasSufficientFunds(value))
            throw new InsufficientFundsException();

        Balance -= value;
    }
}
</code></pre>
<p><strong>Making operations explicit</strong><br>
**<br>
**Next thing we want to do is change the address of a customer. Since
we&rsquo;re not exposing the address property directly, we&rsquo;re also forced to
think about a useful name for the operation; I decided to name it
MoveTo. With this we make things more explicit, and thus more evident
for people who are new to the domain.</p>
<pre><code>public class Customer
{
    public Customer(
        Guid id,
        Name name,
        Address address,
        DateTime birthdate)
    {
        Guard.ForNull(name, &quot;name&quot;);
        Guard.ForNull(address, &quot;address&quot;);
        Guard.ForDateInTheFuture(birthdate, &quot;birthdate&quot;);

        Id = id;
        Name = name;
        Address = address;
        Balance = 0;
    }

    public Guid Id { get; private set; }
    
    private Name Name { get; set; }

    private Address Address { get; set; }

    private DateTime BirthDate { get; set; }

    private decimal Balance { get; set; }

    ...

    public void MoveTo(Address newAddress)
    {
        Guard.ForNull(newAddress, &quot;new address&quot;);

        Address = newAddress;
    }
}

var customer = new Customer(
    Guid.NewGuid(),
    new Name(&quot;Jef&quot;, &quot;Claes&quot;),
    new Address(&quot;Ergens&quot;, &quot;Antwerp&quot;, &quot;Belgium&quot;),
    new DateTime(1987, 10, 18));

customer.MoveTo(new Address(&quot;Quelque part&quot;, &quot;Brussels&quot;, &quot;Belgium&quot;));
</code></pre>
<p><strong>Opening up bit by bit</strong><br>
**<br>
**In the meanwhile our entity is no longer immutable, but we&rsquo;re doing a
good job of not exposing any state. If you&rsquo;re using the same model for
reads as you do for writes, you&rsquo;re going to need to expose some
properties eventually; for querying, but also for assertions. Make sure
to only expose the getters though, and to avoid violating &ldquo;Tell, don&rsquo;t
ask&rdquo; since that became a lot easier now.</p>
<pre><code>public class Customer
{
    public Customer(
        Guid id,
        Name name,
        Address address,
        DateTime birthdate)
    {
        Guard.ForNull(name, &quot;name&quot;);
        Guard.ForNull(address, &quot;address&quot;);
        Guard.ForDateInTheFuture(birthdate, &quot;birthdate&quot;);

        Id = id;
        Name = name;
        Address = address;
        Balance = 0;
    }

    public Guid Id { get; private set; }
    
    public Name Name { get; private set; }

    public Address Address { get; private set; }

    public DateTime BirthDate { get; private set; }

    private decimal Balance { get; set; }

    private bool HasSufficientFunds(decimal value) 
    {
        return Balance - value &gt;= 0;
    }

    public void DecreaseBalance(decimal value)
    {
        if (HasSufficientFunds(value))
            throw new InsufficientFundsException();

        Balance -= value;
    }

    public void MoveTo(Address newAddress)
    {
        Guard.ForNull(newAddress, &quot;new address&quot;);

        Address = newAddress;
    }
}
</code></pre>
<p><strong>Summarized</strong></p>
<p>By making my entities immutable from the start I am guided into adhering
to a bunch of good practices:</p>
<ul>
<li>A constructor</li>
<li>Comparing identities</li>
<li>Defaults</li>
<li>Protecting invariants</li>
<li>Composition and extracting value objects</li>
<li>Tell, don&rsquo;t ask </li>
<li>Making operations explicit</li>
<li>Opening up bit by bit</li>
</ul>
<p>I hope this post made some sense. I&rsquo;d love to hear from you how I could
improve this process, and which process you have accustomed yourself
with over the years.</p>

			</div>

			<div class="tags">
				
					
						<ul class="flat">
							
							<li><a href="/tags/.net">.NET</a></li>
							
							<li><a href="/tags/refactoring">Refactoring</a></li>
							
							<li><a href="/tags/ddd">DDD</a></li>
							
							<li><a href="/tags/ramblings">Ramblings</a></li>
							
						</ul>
					
				
			</div></div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div>2013  <a href="https://github.com/knadh/hugo-ink">Ink</a> theme on <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>

<script>feather.replace()</script>
</body>
</html>
