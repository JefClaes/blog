<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Refactoring on Jef Claes</title>
    <link>http://localhost:1313/tags/refactoring/</link>
    <description>Recent content in Refactoring on Jef Claes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 07 Apr 2013 17:35:00 +0200</lastBuildDate>
    
	<atom:link href="http://localhost:1313/tags/refactoring/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Commands with dependencies</title>
      <link>http://localhost:1313/2012/10/commands-with-dependencies/</link>
      <pubDate>Mon, 15 Oct 2012 16:57:00 +0200</pubDate>
      
      <guid>http://localhost:1313/2012/10/commands-with-dependencies/</guid>
      <description>Also read:Â Separating command data from logic and sending it on a bus
Yesterday I wrote about an architecture which limits abstractions by solely introducing commands and queries. I shared a dead simple variation of this pattern, the advantages I experienced, and how I could still unit test the controller if I wanted to.
At the end of that post I wondered how I would be able to test commands in isolation; suppose the implementation doesn&amp;rsquo;t use a database this time, but a hairy, too low-level, third party webservice.</description>
    </item>
    
    <item>
      <title>Commands, queries and testing</title>
      <link>http://localhost:1313/2012/10/commands-queries-and-testing/</link>
      <pubDate>Sun, 14 Oct 2012 17:45:00 +0200</pubDate>
      
      <guid>http://localhost:1313/2012/10/commands-queries-and-testing/</guid>
      <description>Also read:
 Self-contained commands with dependencies Separating command data from logic and sending it on a bus  We need abstraction, but the amount of abstraction we really need depends, and should be assessed on a case-by-case basis. It seems advisable to grow abstractions, and to introduce them gradually.
That being said, in this post I want to talk about an architecture that tries to limit abstractions to solely commands and queries.</description>
    </item>
    
    <item>
      <title>Some Servicelocator pattern stinks</title>
      <link>http://localhost:1313/2012/04/some-servicelocator-pattern-stinks/</link>
      <pubDate>Tue, 17 Apr 2012 20:33:00 +0200</pubDate>
      
      <guid>http://localhost:1313/2012/04/some-servicelocator-pattern-stinks/</guid>
      <description>I have been working on a somewhat legacy codebase which makes use of the Servicelocator pattern. Although I always thought of Dependecy Injection to be the superior pattern, I was pleased to find some Inversion of Control implementation in there. Working with the codebase, I discovered first hand how easily, when used without caution and discipline, the Servicelocator pattern can introduce code rot.
I will walk you through some of the issues I have with the Servicelocator pattern, mostly looking at it from a test perspective.</description>
    </item>
    
    <item>
      <title>Follow up: Eliminating redundant eventhandlers using a dictionary to map controls</title>
      <link>http://localhost:1313/2010/07/follow-up-eliminating-redundant-eventhandlers-using-a-dictionary-to-map-controls/</link>
      <pubDate>Tue, 13 Jul 2010 20:55:00 +0200</pubDate>
      
      <guid>http://localhost:1313/2010/07/follow-up-eliminating-redundant-eventhandlers-using-a-dictionary-to-map-controls/</guid>
      <description>Yesterday I blogged on &amp;lsquo;WebForms refactoring: Eliminating redundant eventhandlers using a dictionary to map controls&#39;. In this post I went from bad code to better code. A smart reader gave me some good pointers on how to improve this code some more. Another iteration was necessary.
Losing the LinqIn the previous iteration I used Linq to search my dictionary.
 1: var res = mappings.Where(map =&amp;gt; map.Key.Equals((CheckBox)sender)).First();  This is overhead, because the dictionary implements an indexer.</description>
    </item>
    
    <item>
      <title>WebForms refactoring: Eliminating redundant eventhandlers using a dictionary to map controls</title>
      <link>http://localhost:1313/2010/07/webforms-refactoring-eliminating-redundant-eventhandlers-using-a-dictionary-to-map-controls/</link>
      <pubDate>Mon, 12 Jul 2010 21:35:00 +0200</pubDate>
      
      <guid>http://localhost:1313/2010/07/webforms-refactoring-eliminating-redundant-eventhandlers-using-a-dictionary-to-map-controls/</guid>
      <description>Last week I came across a problem which seemed trivial at first sight, but turned out to be a pretty fun refactoring challenge.
The scenarioThe real problem was a bit more complex, but for simplicity&amp;rsquo;s sake I made this example. In this form there are three checkboxes which map with the textboxes next to them. If the checkbox gets unchecked the corresponding textboxes should be cleared.

First iterationI warn you.</description>
    </item>
    
  </channel>
</rss>