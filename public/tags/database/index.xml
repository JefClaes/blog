<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>database on Jef Claes</title>
    <link>http://localhost:1313/tags/database/</link>
    <description>Recent content in database on Jef Claes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 26 Jan 2014 18:00:00 +0100</lastBuildDate>
    
	<atom:link href="http://localhost:1313/tags/database/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Databases are growing on me</title>
      <link>http://localhost:1313/2013/12/databases-are-growing-on-me/</link>
      <pubDate>Sun, 22 Dec 2013 21:53:00 +0100</pubDate>
      
      <guid>http://localhost:1313/2013/12/databases-are-growing-on-me/</guid>
      <description>I learned all about logical design of relational databases back in school; tables, columns, data types, views, normalization, constraints, primary keys, foreign keys&amp;hellip; At the same time, I learned how to use SQL to put data in, and how to get it out again; INSERT INTO, SELECT, FROM, WHERE, JOIN, GROUP&amp;hellip;
In the first project I worked on just out of school, we weren&amp;rsquo;t doing anything interesting with databases; we didn&amp;rsquo;t have that many users, or that much data.</description>
    </item>
    
    <item>
      <title>An event store with optimistic concurrency</title>
      <link>http://localhost:1313/2013/11/an-event-store-with-optimistic-concurrency/</link>
      <pubDate>Sun, 10 Nov 2013 18:25:00 +0100</pubDate>
      
      <guid>http://localhost:1313/2013/11/an-event-store-with-optimistic-concurrency/</guid>
      <description>Like I mentioned last week - after only five posts on the subject - there still are a great deal of event sourcing nuances left to be discovered.
My current event store implementation only supports a single user. Due to an aggressive file lock, concurrently accessing an aggregate will throw an exception. Can we allow multiple users to write to and read from an event stream? Also, what can we do about users making changes to the same aggregate; can we somehow detect conflicts and avoid changes to be committed?</description>
    </item>
    
    <item>
      <title>Event projections</title>
      <link>http://localhost:1313/2013/10/event-projections/</link>
      <pubDate>Sun, 27 Oct 2013 17:43:00 +0100</pubDate>
      
      <guid>http://localhost:1313/2013/10/event-projections/</guid>
      <description>In my first two posts on event sourcing, I implemented an event sourced aggregate from scratch. After being able to have an aggregate record and play events, I looked at persisting them in an event store. Logically, the next question is: how do I query my aggregates, how do I get my state out?
In traditional systems, write and read models are not separated, they are one and the same. Event sourced systems on the other hand have a write model - event streams, and a separate read model.</description>
    </item>
    
    <item>
      <title>It&#39;s not cake we are baking</title>
      <link>http://localhost:1313/2012/12/its-not-cake-we-are-baking/</link>
      <pubDate>Sun, 09 Dec 2012 16:08:00 +0100</pubDate>
      
      <guid>http://localhost:1313/2012/12/its-not-cake-we-are-baking/</guid>
      <description>I recently watched a talk on Vimeo where Christin Gorman talks about how cookie dough relates to Hibernate; why use the generic, bloated and one-fits-all solution when you can mix together your own yummy cookie dough? We should aspire to be the Gordon Ramsey of software, not the college student who can only cook Ramen noodles. If you haven&amp;rsquo;t watched or listened to her talk, you should; it&amp;rsquo;s only a few minutes long, and she brings it really well.</description>
    </item>
    
    <item>
      <title>Painless database logging with mongoDB</title>
      <link>http://localhost:1313/2012/05/painless-database-logging-with-mongodb/</link>
      <pubDate>Sun, 20 May 2012 17:18:00 +0200</pubDate>
      
      <guid>http://localhost:1313/2012/05/painless-database-logging-with-mongodb/</guid>
      <description>While browsing the source code of the ELMAH mongoDB provider, I learned about a special type of collections: capped collections.
From the mongoDB documentation:
 Capped collections are fixed sized collections that have a very high performance auto-FIFO age-out feature (age out is based on insertion order). In addition, capped collections automatically, with high performance, maintain insertion order for the documents in the collection; this is very powerful for certain use cases such as logging.</description>
    </item>
    
  </channel>
</rss>