<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Browsers on Jef Claes</title>
    <link>http://localhost:1313/tags/browsers/</link>
    <description>Recent content in Browsers on Jef Claes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 19 Jan 2012 20:56:00 +0100</lastBuildDate>
    
	<atom:link href="http://localhost:1313/tags/browsers/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Recursively spawning Web Workers</title>
      <link>http://localhost:1313/2011/07/recursively-spawning-web-workers/</link>
      <pubDate>Thu, 21 Jul 2011 15:00:00 +0200</pubDate>
      
      <guid>http://localhost:1313/2011/07/recursively-spawning-web-workers/</guid>
      <description>I like to think of HTML5 Web Workers simply as &amp;lsquo;threading for the Web&amp;rsquo;.
Wikipedia describes it a bit more in detail.
 Web Workers define an API for running scripts, basically JavaScript, in the background independently of any user interface scripts. This allows for long-running scripts that are not interrupted by scripts that respond to clicks or other user interactions, and allows long tasks to be executed without yielding to keep the page responsive.</description>
    </item>
    
    <item>
      <title>Internet Explorer, how could you miss this?</title>
      <link>http://localhost:1313/2011/07/internet-explorer-how-could-you-miss-this/</link>
      <pubDate>Sun, 17 Jul 2011 15:30:00 +0200</pubDate>
      
      <guid>http://localhost:1313/2011/07/internet-explorer-how-could-you-miss-this/</guid>
      <description>Modern browsers keep making efforts to make the web a better place. One of those small, but so thoughtful features, is a way to tame unwanted dialogs.
If I run following JavaScript, Chrome and Firefox both help me disabling it.
for (var i = 0; i &amp;lt; 1000; i++) { alert(&amp;quot;Annoying alert &amp;quot; + i); }  
Internet Explorer does not. Even if I kill the process of the tab, the tab will try to restore itself, forcing me to kill Internet Explorer as a whole.</description>
    </item>
    
    <item>
      <title>Keeping WebSockets alive</title>
      <link>http://localhost:1313/2011/03/keeping-websockets-alive/</link>
      <pubDate>Sat, 12 Mar 2011 17:40:00 +0100</pubDate>
      
      <guid>http://localhost:1313/2011/03/keeping-websockets-alive/</guid>
      <description>The problem with using stateful connections on an imperfect place as the internet is that connections might drop. The server or an intermediary can drop the connection due to an idle timeout. Even a temporary problem at the server or a local network hiccup might kill your connection.
If you aren&amp;rsquo;t prepared to handle these scenarios, you will not be able to fully rely on WebSockets.
A simple solution
The simplest solution is checking every few seconds whether the WebSocket is still opened.</description>
    </item>
    
    <item>
      <title>I will be talking at HTML5 WebCamps!</title>
      <link>http://localhost:1313/2011/03/i-will-be-talking-at-html5-webcamps/</link>
      <pubDate>Tue, 01 Mar 2011 12:56:00 +0100</pubDate>
      
      <guid>http://localhost:1313/2011/03/i-will-be-talking-at-html5-webcamps/</guid>
      <description>HTML5 WebCamps is a free event organized by Microsoft Belgium and will take place on April 6th at Living Tomorrow.
In my session I will be talking about WebSockets.
 WebSockets on Fire
While the WebSockets API specification is not stable yet, various browser vendors have already implemented a prototype in their latest browser versions. Microsoft released their WebSockets prototype in December 2010. While there is no native implementation of WebSockets in IE9 just yet, for now they are providing a solution which works cross-browser, relying on a Silverlight client.</description>
    </item>
    
    <item>
      <title>HTML5: Installing the Microsoft WebSockets prototype</title>
      <link>http://localhost:1313/2011/01/html5-installing-the-microsoft-websockets-prototype/</link>
      <pubDate>Sat, 08 Jan 2011 20:30:00 +0100</pubDate>
      
      <guid>http://localhost:1313/2011/01/html5-installing-the-microsoft-websockets-prototype/</guid>
      <description>In December Microsoft launched the HTML5 Labs for experimental HTML5 technologies still under development. With the launch, they also released a WebSockets prototype.
In this post I will lead you through the process of installing the WebSockets prototype on your machine. By the end of this tutorial you should have a working chat web application sample.
Download
First you need to download and run the WebSockets prototype installer.
This package installs the binaries and samples in the %ProgramFiles%\Microsoft SDKs\WCF WebSockets\10.</description>
    </item>
    
    <item>
      <title>Format JavaScript with the IE9 developer tools</title>
      <link>http://localhost:1313/2010/12/format-javascript-with-the-ie9-developer-tools/</link>
      <pubDate>Mon, 27 Dec 2010 19:30:00 +0100</pubDate>
      
      <guid>http://localhost:1313/2010/12/format-javascript-with-the-ie9-developer-tools/</guid>
      <description>One of the new features in the IE9 developer tools Giorgio Sardo demoed at TechEd Europe, is the Format JavaScript tool. This tool can be very useful when you want to reverse engineer a minified script.
You can find this feature in the toolbox on the Script tab.

This is how jquery.min.js looks after formatting.

This feature is not available in the public beta (9.0.7.9360.16406), but should be available in the latest platform previews.</description>
    </item>
    
    <item>
      <title>HTML5: Exception handling with the Geolocation API</title>
      <link>http://localhost:1313/2010/12/html5-exception-handling-with-the-geolocation-api/</link>
      <pubDate>Sun, 26 Dec 2010 20:30:00 +0100</pubDate>
      
      <guid>http://localhost:1313/2010/12/html5-exception-handling-with-the-geolocation-api/</guid>
      <description>In my previous post on the Geolocation API I passed in a PositionErrorCallback to the geolocation.getCurrentPosition() method. When I received this callback I displayed a generic message informing the user something went wrong. In real-world scenarios you probably want the message to be more specific. You might also want to call a specific fallback method depending on what went wrong.
This is where the PositionError argument of the PositionErrorCallback comes in handy.</description>
    </item>
    
    <item>
      <title>HTML5: The Geolocation API is scary (good)</title>
      <link>http://localhost:1313/2010/12/html5-the-geolocation-api-is-scary-good/</link>
      <pubDate>Sun, 19 Dec 2010 17:30:00 +0100</pubDate>
      
      <guid>http://localhost:1313/2010/12/html5-the-geolocation-api-is-scary-good/</guid>
      <description>I read about the HTML5 Geolocation API in the Pro HTML5 Programming book a while ago, and decided to play with it on this lazy Sunday.
Using the Geolocation API to make a one-shot position request is very straight-forward. Get a reference to the navigator.geolocation object and call the getCurrentPosition() method, passing in at least a PositionCallback. In this example I&amp;rsquo;m also passing in a PositionErrorCallback. In the PositionCallback you can examine the properties of the position object.</description>
    </item>
    
    <item>
      <title>HTML5 selectors and jQuery</title>
      <link>http://localhost:1313/2010/12/html5-selectors-and-jquery/</link>
      <pubDate>Sun, 12 Dec 2010 13:09:00 +0100</pubDate>
      
      <guid>http://localhost:1313/2010/12/html5-selectors-and-jquery/</guid>
      <description>In my first post on the HTML5 javascript Selector API I wondered how the new methods querySelector() and querySelectorAll() would influence jQuery.
At the time, I couldn&amp;rsquo;t find any information on the subject, but yesterday I found out that jQuery has been taking advantage of these new methods since version 1.4.3.
From the release notes..
 The performance of nearly all the major traversal methods has been drastically improved. .closest(), .</description>
    </item>
    
    <item>
      <title>More accurate javascript execution time measurement with the msPerformance API</title>
      <link>http://localhost:1313/2010/12/more-accurate-javascript-execution-time-measurement-with-the-msperformance-api/</link>
      <pubDate>Fri, 10 Dec 2010 20:00:00 +0100</pubDate>
      
      <guid>http://localhost:1313/2010/12/more-accurate-javascript-execution-time-measurement-with-the-msperformance-api/</guid>
      <description>A cool feature of Internet Explorer 9 is the msPerformance API. This API helps you to accurately measure the performance of a webpage. A lot of developers have built their own performance measurement constructs over the years, based on the Date function, but the results of these constructs can be way off!
John Resig (jQuery inventor) has an in detail blogpost where he discovers where custom javascript execution time measurement goes wrong.</description>
    </item>
    
    <item>
      <title>HTML5: Drawing images to the canvas gotcha</title>
      <link>http://localhost:1313/2010/12/html5-drawing-images-to-the-canvas-gotcha/</link>
      <pubDate>Sun, 05 Dec 2010 19:55:00 +0100</pubDate>
      
      <guid>http://localhost:1313/2010/12/html5-drawing-images-to-the-canvas-gotcha/</guid>
      <description>While I was playing with the Canvas API I came across a weird issue: I was trying to draw an image to the canvas, but the image failed to render very often.
Have a look at the source. Do you spot the problem?
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;HTML5: Canvas&amp;lt;/title&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; window.addEventListener(&amp;quot;load&amp;quot;, draw, true); function draw(){ var canvas = document.getElementById(&#39;canvas&#39;); var context = canvas.getContext(&#39;2d&#39;); var img = new Image(); img.src = &amp;quot;http://3.</description>
    </item>
    
    <item>
      <title>HTML5: More on selectors</title>
      <link>http://localhost:1313/2010/12/html5-more-on-selectors/</link>
      <pubDate>Sun, 05 Dec 2010 13:15:00 +0100</pubDate>
      
      <guid>http://localhost:1313/2010/12/html5-more-on-selectors/</guid>
      <description>Last weekend I blogged on new addittions to the javascript Selector API: querySelector() and querySelectorAll(). These two new methods enable you to find elements by matching against a group of selectors. I only scratched the surface in the previous post, that&amp;rsquo;s why you can find a few more examples in this post. These examples should demonstrate the power and ease of use of the new Selector API features. It&amp;rsquo;s impossible to show you all of the selectors usages in just one post, that&amp;rsquo;s why I strongly encourage you to have a look at the W3C Selectors specifications.</description>
    </item>
    
    <item>
      <title>HTML5: New in the javascript Selector API</title>
      <link>http://localhost:1313/2010/11/html5-new-in-the-javascript-selector-api/</link>
      <pubDate>Mon, 29 Nov 2010 19:30:00 +0100</pubDate>
      
      <guid>http://localhost:1313/2010/11/html5-new-in-the-javascript-selector-api/</guid>
      <description>Because I finally got the MCTS 70-536 certification out of the way, I can start experimenting with some fun stuff again. One of the things on the top of my list is HTML5. I started reading the book Pro HTML5 Programming, so expect more posts on HTML5 in the near future.
In this post I will show you two new methods in the javascript Selector API which are extremely useful to find elements.</description>
    </item>
    
    <item>
      <title>Response.RedirectPermanent in .NET 3.5 and older</title>
      <link>http://localhost:1313/2009/12/response.redirectpermanent-in-.net-3.5-and-older/</link>
      <pubDate>Sat, 05 Dec 2009 17:50:00 +0100</pubDate>
      
      <guid>http://localhost:1313/2009/12/response.redirectpermanent-in-.net-3.5-and-older/</guid>
      <description>One of the new features in ASP.NET 4.0 is permanently redirecting to a page using Response.RedirectPermanent.
 It is common practice in Web applications to move pages and other content around over time, which can lead to an accumulation of stale links in search engines. In ASP.NET, developers have traditionally handled requests to old URLs by using by using the Response.Redirect method to forward a request to the new URL. However, the Redirect method issues an HTTP 302 Found (temporary redirect) response, which results in an extra HTTP round trip when users attempt to access the old URLs.</description>
    </item>
    
  </channel>
</rss>