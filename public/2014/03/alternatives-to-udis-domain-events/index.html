<!DOCTYPE html>
<html>
<head><script src="/livereload.js?port=1313&mindelay=10&v=2" data-no-instant defer></script>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Alternatives to Udi&#39;s domain events - Jef Claes</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta itemprop="name" content="Alternatives to Udi&#39;s domain events">
<meta itemprop="description" content="Almost four years ago Udi Dahan introduced an elegant technique that allows you to have your domain model dispatch events without injecting a dispatcher into the model - keeping your model focused on the business at hand.
This works by having a static DomainEvents class which dispatches raised events.
This customer aggregate raises an event when a customer moves to a new address.
public class Customer { private readonly string _id; private Address _address; private Name _name; public Customer(string id, Name name, Address address) { Guard.">
<meta itemprop="datePublished" content="2014-03-02T18:21:00&#43;01:00" />
<meta itemprop="dateModified" content="2014-03-02T18:21:00&#43;01:00" />
<meta itemprop="wordCount" content="406">



<meta itemprop="keywords" content="CodeSnippets,.NET,DDD," /><meta property="og:title" content="Alternatives to Udi&#39;s domain events" />
<meta property="og:description" content="Almost four years ago Udi Dahan introduced an elegant technique that allows you to have your domain model dispatch events without injecting a dispatcher into the model - keeping your model focused on the business at hand.
This works by having a static DomainEvents class which dispatches raised events.
This customer aggregate raises an event when a customer moves to a new address.
public class Customer { private readonly string _id; private Address _address; private Name _name; public Customer(string id, Name name, Address address) { Guard." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/2014/03/alternatives-to-udis-domain-events/" />
<meta property="article:published_time" content="2014-03-02T18:21:00+01:00" />
<meta property="article:modified_time" content="2014-03-02T18:21:00+01:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Alternatives to Udi&#39;s domain events"/>
<meta name="twitter:description" content="Almost four years ago Udi Dahan introduced an elegant technique that allows you to have your domain model dispatch events without injecting a dispatcher into the model - keeping your model focused on the business at hand.
This works by having a static DomainEvents class which dispatches raised events.
This customer aggregate raises an event when a customer moves to a new address.
public class Customer { private readonly string _id; private Address _address; private Name _name; public Customer(string id, Name name, Address address) { Guard."/>
<link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/main.css" />

        <link id="dark-scheme" rel="stylesheet" type="text/css" href="http://localhost:1313/css/dark.css" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
		<script src="http://localhost:1313/js/main.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	
		<div class="avatar">
			<a href="http://localhost:1313/">
				<img src="https://image.freepik.com/free-vector/young-man-head-with-beard-avatar-character_24877-36786.jpg" alt="Jef Claes" />
			</a>
		</div>
	
	<h1 class="site-title"><a href="http://localhost:1313/">Jef Claes</a></h1>
	<div class="site-description"><p>On software and life</p><nav class="nav social">
			<ul class="flat"><li><a href="https://github.com/jefclaes" title="Github"><i data-feather="github"></i></a></li><li><a href="/index.xml" title="RSS"><i data-feather="rss"></i></a></li></ul>
		</nav></div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/post">All posts</a>
			</li>
			
			<li>
				<a href="/about">About</a>
			</li>
			
			<li>
				<a href="/tags">Tags</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post">
			<div class="post-header">
				
					<div class="meta">
						<div class="date">
							<span class="day">02</span>
							<span class="rest">Mar 2014</span>
						</div>
					</div>
				
				<div class="matter">
					<h1 class="title">Alternatives to Udi&#39;s domain events</h1>
				</div>
			</div>
					
			<div class="markdown">
				<p>Almost four years ago <a href="http://www.udidahan.com/2009/06/14/domain-events-salvation/">Udi Dahan introduced an elegant
technique</a>
that allows you to have your domain model dispatch events without
injecting a dispatcher into the model - keeping your model focused on
the business at hand.</p>
<p>This works by having a static DomainEvents class which dispatches raised
events.</p>
<p>This customer aggregate raises an event when a customer moves to a new
address.</p>
<pre><code>public class Customer
{
    private readonly string _id;
    private Address _address;
    private Name _name;

    public Customer(string id, Name name, Address address)
    {
        Guard.ForNullOrEmpty(id, &quot;id&quot;);
        Guard.ForNull(name, &quot;name&quot;);
        Guard.ForNull(address, &quot;address&quot;);

        _id = id;
        _name = name;
        _address = address;
    }

    public void Move(Address newAddress)
    {
        Guard.ForNull(newAddress, &quot;newAddress&quot;);

        _address = newAddress;

        DomainEvents.Raise(new CustomerMoved(_id));
    }
}
</code></pre>
<p>By having a dispatcher implementation that records the events instead of
dispatching them, we can test whether the aggregate raised the correct
domain event.</p>
<pre><code>var recordingDispatcher = new RecordingDispatcher();
DomainEvents.Dispatcher = recordingDispatcher;

var customer = new Customer(
    &quot;customer/1&quot;,
    new Name(&quot;Jef&quot;, &quot;Claes&quot;),
    new Address(&quot;Main Street&quot;, &quot;114B&quot;, &quot;Antwerp&quot;, &quot;2018&quot;));
customer.Move(new Address(&quot;Baker Street&quot;, &quot;89&quot;, &quot;Antwerp&quot;, &quot;2018&quot;));

recordingDispatcher.Raised(new CustomerMoved(&quot;customer/1&quot;)); // true
</code></pre>
<p>While this worked out great for a good while, I bumped into difficulties
scoping my unit of work and such when I redid some of my infrastructure.
While there are ways to have your container address these issues,
getting rid of the static components is simpler throughout. Â </p>
<p>A popular event sourcing pattern is to have your aggregate record
events. There is no reason why we couldn&rsquo;t apply the same pattern here.
Using this technique, we still avoid having to inject something into our
models, plus we get rid of that static DomainEvents component.
Reponsibility of dispatching the events is now delegated to an upper
layer.</p>
<pre><code>public class Customer : IRecordEvents
{
    private readonly EventRecorder _recorder = new EventRecorder();

    private readonly string _id;
    private Address _address;
    private Name _name;

    public Customer(string id, Name name, Address address)
    {
        Guard.ForNullOrEmpty(id, &quot;id&quot;);
        Guard.ForNull(name, &quot;name&quot;);
        Guard.ForNull(address, &quot;address&quot;);

        _id = id;
        _name = name;
        _address = address;
    }

    public EventStream RecordedEvents() 
    {
        return _recorder.RecordedEvents();
    }

    public void Move(Address newAddress)
    {
        Guard.ForNull(newAddress, &quot;newAddress&quot;);

        _address = newAddress;

        _recorder.Record(new CustomerMoved(_id));
    }
}

var customer = new Customer(
    &quot;customer/1&quot;,
    new Name(&quot;Jef&quot;, &quot;Claes&quot;),
    new Address(&quot;Main Street&quot;, &quot;114B&quot;, &quot;Antwerp&quot;, &quot;2018&quot;));
customer.Move(new Address(&quot;Baker Street&quot;, &quot;89&quot;, &quot;Antwerp&quot;, &quot;2018&quot;));

customer.RecordedEvents().Contains(new CustomerMoved(&quot;customer/1&quot;)); // true
</code></pre>
<p>Another altnernative is to <a href="http://www.jayway.com/2013/06/20/dont-publish-domain-events-return-them/">return events from your
methods</a>.
This technique puts the responsibility of aggregating all events on to a
higher layer. Better to put that closer to the aggregate.</p>
<p>What patterns are you using?</p>

			</div>

			<div class="tags">
				
					
						<ul class="flat">
							
							<li><a href="/tags/codesnippets">CodeSnippets</a></li>
							
							<li><a href="/tags/.net">.NET</a></li>
							
							<li><a href="/tags/ddd">DDD</a></li>
							
						</ul>
					
				
			</div></div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div>2014  <a href="https://github.com/knadh/hugo-ink">Ink</a> theme on <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>

<script>feather.replace()</script>
</body>
</html>
