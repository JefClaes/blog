<!DOCTYPE html>
<html>
<head><script src="/livereload.js?port=1313&mindelay=10&v=2" data-no-instant defer></script>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Sending commands from a knockout.js view model - Jef Claes</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta itemprop="name" content="Sending commands from a knockout.js view model">
<meta itemprop="description" content="While I got to use angular.js for a good while last year, I found myself returning to knockout.js for the current application I&rsquo;m working on. Where angular.js is a heavy, intrusive, opinionated, but also very complete framework, knockout.js is a small and lightweight library giving you not much more than a dynamic model binder. So instead of blindly following the angular-way, I&rsquo;ll have to introduce my own set of abstractions and plumbing again; I assume that I&rsquo;ll end up with a lot less.">
<meta itemprop="datePublished" content="2014-03-23T18:31:00&#43;01:00" />
<meta itemprop="dateModified" content="2014-03-23T18:31:00&#43;01:00" />
<meta itemprop="wordCount" content="550">



<meta itemprop="keywords" content="CodeSnippets,AJAX,javascript,ASPNET MVC," /><meta property="og:title" content="Sending commands from a knockout.js view model" />
<meta property="og:description" content="While I got to use angular.js for a good while last year, I found myself returning to knockout.js for the current application I&rsquo;m working on. Where angular.js is a heavy, intrusive, opinionated, but also very complete framework, knockout.js is a small and lightweight library giving you not much more than a dynamic model binder. So instead of blindly following the angular-way, I&rsquo;ll have to introduce my own set of abstractions and plumbing again; I assume that I&rsquo;ll end up with a lot less." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/2014/03/sending-commands-from-a-knockout.js-view-model/" />
<meta property="article:published_time" content="2014-03-23T18:31:00+01:00" />
<meta property="article:modified_time" content="2014-03-23T18:31:00+01:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Sending commands from a knockout.js view model"/>
<meta name="twitter:description" content="While I got to use angular.js for a good while last year, I found myself returning to knockout.js for the current application I&rsquo;m working on. Where angular.js is a heavy, intrusive, opinionated, but also very complete framework, knockout.js is a small and lightweight library giving you not much more than a dynamic model binder. So instead of blindly following the angular-way, I&rsquo;ll have to introduce my own set of abstractions and plumbing again; I assume that I&rsquo;ll end up with a lot less."/>
<link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/main.css" />

        <link id="dark-scheme" rel="stylesheet" type="text/css" href="http://localhost:1313/css/dark.css" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
		<script src="http://localhost:1313/js/main.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	
		<div class="avatar">
			<a href="http://localhost:1313/">
				<img src="https://image.freepik.com/free-vector/young-man-head-with-beard-avatar-character_24877-36786.jpg" alt="Jef Claes" />
			</a>
		</div>
	
	<h1 class="site-title"><a href="http://localhost:1313/">Jef Claes</a></h1>
	<div class="site-description"><p>On software and life</p><nav class="nav social">
			<ul class="flat"><li><a href="https://github.com/jefclaes" title="Github"><i data-feather="github"></i></a></li><li><a href="/index.xml" title="RSS"><i data-feather="rss"></i></a></li></ul>
		</nav></div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/post">All posts</a>
			</li>
			
			<li>
				<a href="/about">About</a>
			</li>
			
			<li>
				<a href="/tags">Tags</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post">
			<div class="post-header">
				
					<div class="meta">
						<div class="date">
							<span class="day">23</span>
							<span class="rest">Mar 2014</span>
						</div>
					</div>
				
				<div class="matter">
					<h1 class="title">Sending commands from a knockout.js view model</h1>
				</div>
			</div>
					
			<div class="markdown">
				<p>While I got to use <a href="http://angularjs.org/">angular.js</a> for a good while
last year, I found myself returning to
<a href="http://knockoutjs.com/">knockout.js</a> for the current application I&rsquo;m
working on. Where angular.js is a heavy, intrusive, opinionated, but
also very complete framework, knockout.js is a small and lightweight
library giving you not much more than a dynamic model binder. So instead
of blindly following the angular-way, I&rsquo;ll have to introduce my own set
of abstractions and plumbing again; I assume that I&rsquo;ll end up with a lot
less.</p>
<p>Let&rsquo;s say that I have a view model for making a deposit.</p>
<pre><code>var DepositViewModel = function() {
    var self = this;

    self.account = ko.observable('');
    self.amount = ko.observable(0);

    self.depositEnabled = ko.computed(function() {
        return self.account() !== '' &amp;&amp; self.amount() &gt; 0;
    });
    
    self.deposit = function() {
        if (!self.depositEnabled()) {
            throw new Error('Deposit should be enabled.');
        }

        $.ajax({ 
            url: '/Commands/Deposit', 
            data: { account: self.account(), amount: self.amount() }, 
            success: function() { self.amount(0); }
            type: 'POST', 
            dataType: 'json' 
        });
    };
};

ko.applyBindings(new DepositViewModel());
</code></pre>
<p>Writing a test for this, it was obvious that I couldn&rsquo;t have my deposit
function make requests directly. An abstraction that has served me well
in the past, is a command executor. </p>
<pre><code>CommandExecutor = function() {
    this.execute = function(command, success) { };
};
</code></pre>
<p>We can have an implementation that handles each command individually, or
we can have it send requests to our server by convention. The
implementation below assumes that the name of our command has a
corresponding endpoint on the server. </p>
<pre><code>CommandExecutor = function() {

    this.execute = function(command, success) {

        if (console) {
            console.log('Executing command..');
            console.log(command);
        }

        $.ajax({ 
            url: '/Commands/' + command.name, data: command.data, 
            success: success
            type: 'POST', dataType: 'json' 
        });

    };
};
</code></pre>
<p>While angular.js has dependency management built in, we can get away by
injecting dependencies manually and a bit of bootstrapping - it&rsquo;s not
that I often have large dependency graphs in the browser, or that I care
much about the life cycles of my components.</p>
<pre><code>var DepositViewModel = function(dependencies) {
    var self = this;

    self.account = ko.observable('');
    self.amount = ko.observable(0);

    self.depositEnabled = ko.computed(function() {
        return self.account() !== '' &amp;&amp; self.amount() &gt; 0;
    });
    
    self.deposit = function() {
        if (!self.depositEnabled()) {
            throw new Error('Deposit should be enabled.');
        }

        var command = { 
            name: 'Deposit', 
            data: { account: self.account(), amount: self.amount() } };
        var callback = function() { self.amount(0); };
        dependencies.commandExecutor.execute(command, callback);
    };
};

ko.applyBindings(new DepositViewModel({ commandExecutor: new CommandExecutor() }));
</code></pre>
<p>See, very little magic required.</p>
<p>Writing a test, we now only need to replace the command executor with an
implementation that will record commands instead of actually sending
them to the server.</p>
<pre><code>var CommandExecutorMock = function () {

    var commands = [];

    this.execute = function (command, success) {
        commands.push(command);
        success();
    };
    this.verifyCommandWasExecuted = function(command) {
        for (var i = 0; i &lt; commands.length; i++) {
            if (JSON.stringify(commands[i]) === JSON.stringify(command)) {
                return true;                        
            }
        }
        return false;
    };

};

describe(&quot;When a deposit is invoked&quot;, function () {

    var commandExecutor = new CommandExecutorMock();
    
    var model = new DepositViewModel({ commandExecutor: commandExecutor });
    model.account('MyAccount');
    model.amount(100);
    model.deposit();

    it(&quot;a deposit command is sent.&quot;, function() {
        var command = {
            name: 'Deposit', 
            data: { account: 'MyAccount', amount: 100 }
        };

        expect(commandExecutor.verifyCommandWasExecuted(command)).toBe(true);
    });  

});
</code></pre>
<p>I did something similar for queries, and ended up with not that much
code, that didn&rsquo;t even take that long to write. I&rsquo;m curious to see how
this application will evolve.</p>

			</div>

			<div class="tags">
				
					
						<ul class="flat">
							
							<li><a href="/tags/codesnippets">CodeSnippets</a></li>
							
							<li><a href="/tags/ajax">AJAX</a></li>
							
							<li><a href="/tags/javascript">javascript</a></li>
							
							<li><a href="/tags/aspnet-mvc">ASPNET MVC</a></li>
							
						</ul>
					
				
			</div></div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div>2014  <a href="https://github.com/knadh/hugo-ink">Ink</a> theme on <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>

<script>feather.replace()</script>
</body>
</html>
