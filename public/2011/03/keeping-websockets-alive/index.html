<!DOCTYPE html>
<html>
<head><script src="/livereload.js?port=1313&mindelay=10&v=2" data-no-instant defer></script>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Keeping WebSockets alive - Jef Claes</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta itemprop="name" content="Keeping WebSockets alive">
<meta itemprop="description" content="The problem with using stateful connections on an imperfect place as the internet is that connections might drop. The server or an intermediary can drop the connection due to an idle timeout. Even a temporary problem at the server or a local network hiccup might kill your connection.
If you aren&rsquo;t prepared to handle these scenarios, you will not be able to fully rely on WebSockets.
A simple solution
The simplest solution is checking every few seconds whether the WebSocket is still opened.">
<meta itemprop="datePublished" content="2011-03-12T17:40:00&#43;01:00" />
<meta itemprop="dateModified" content="2011-03-12T17:40:00&#43;01:00" />
<meta itemprop="wordCount" content="482">



<meta itemprop="keywords" content="Microsoft,Browsers,Hack,HTML5," /><meta property="og:title" content="Keeping WebSockets alive" />
<meta property="og:description" content="The problem with using stateful connections on an imperfect place as the internet is that connections might drop. The server or an intermediary can drop the connection due to an idle timeout. Even a temporary problem at the server or a local network hiccup might kill your connection.
If you aren&rsquo;t prepared to handle these scenarios, you will not be able to fully rely on WebSockets.
A simple solution
The simplest solution is checking every few seconds whether the WebSocket is still opened." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/2011/03/keeping-websockets-alive/" />
<meta property="article:published_time" content="2011-03-12T17:40:00+01:00" />
<meta property="article:modified_time" content="2011-03-12T17:40:00+01:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Keeping WebSockets alive"/>
<meta name="twitter:description" content="The problem with using stateful connections on an imperfect place as the internet is that connections might drop. The server or an intermediary can drop the connection due to an idle timeout. Even a temporary problem at the server or a local network hiccup might kill your connection.
If you aren&rsquo;t prepared to handle these scenarios, you will not be able to fully rely on WebSockets.
A simple solution
The simplest solution is checking every few seconds whether the WebSocket is still opened."/>
<link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/main.css" />

        <link id="dark-scheme" rel="stylesheet" type="text/css" href="http://localhost:1313/css/dark.css" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
		<script src="http://localhost:1313/js/main.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	
		<div class="avatar">
			<a href="http://localhost:1313/">
				<img src="https://image.freepik.com/free-vector/young-man-head-with-beard-avatar-character_24877-36786.jpg" alt="Jef Claes" />
			</a>
		</div>
	
	<h1 class="site-title"><a href="http://localhost:1313/">Jef Claes</a></h1>
	<div class="site-description"><p>On software and life</p><nav class="nav social">
			<ul class="flat"><li><a href="https://github.com/jefclaes" title="Github"><i data-feather="github"></i></a></li><li><a href="/index.xml" title="RSS"><i data-feather="rss"></i></a></li></ul>
		</nav></div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/post">All posts</a>
			</li>
			
			<li>
				<a href="/about">About</a>
			</li>
			
			<li>
				<a href="/tags">Tags</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post">
			<div class="post-header">
				
					<div class="meta">
						<div class="date">
							<span class="day">12</span>
							<span class="rest">Mar 2011</span>
						</div>
					</div>
				
				<div class="matter">
					<h1 class="title">Keeping WebSockets alive</h1>
				</div>
			</div>
					
			<div class="markdown">
				<p>The problem with using stateful connections on an imperfect place as the
internet is that connections might drop. The server or an intermediary
can drop the connection due to an idle timeout. Even a temporary problem
at the server or a local network hiccup might kill your connection.</p>
<p>If you aren&rsquo;t prepared to handle these scenarios, you will not be able
to fully rely on <a href="http://websocket.org/">WebSockets</a>.</p>
<p><strong>A simple solution</strong></p>
<p>The simplest solution is checking every few seconds whether the
WebSocket is still opened. This might suffice in a good amount of
scenarios, but a lot of other scenarios require more stable
connectivity.</p>
<pre><code>$(document).ready(function () {        

    setInterval(openWebSocket, 5000);

}

 

function openWebSocket(){

    if (websocket.readyState === undefined || websocket.readyState &gt; 1) {

        ...

    }

}
</code></pre>
<p><strong>Keepalives</strong></p>
<p>As mentioned before, the server or an intermediate might drop the
connection when the connection becomes idle. To prevent this, you could
make your server send keepalive messages at predefined intervals.</p>
<p>I implemented this in the <a href="http://jclaes.blogspot.com/2011/01/html5-rebuilding-websockets-server.html">HTML5 Labs WCF
Server</a>.</p>
<pre><code>[ServiceBehavior(InstanceContextMode = InstanceContextMode.PerSession, 

                 ConcurrencyMode = ConcurrencyMode.Multiple)]

public class CadSubscriptionService : WebSocketsService {

    private static KeepAliveBroadcaster _keepAliveBroadcaster;

 

    public CadSubscriptionService() {           

        if (_keepAliveBroadcaster == null) {

            _keepAliveBroadcaster = new KeepAliveBroadcaster();

        }

    }

 

    public override void OnOpen() {

        _keepAliveBroadcaster.AddService(this);

        base.OnOpen();

    }

 

    protected override void OnClose(object sender, EventArgs e) {

        _keepAliveBroadcaster.RemoveService(this);

        base.OnClose(sender, e);

    }     

}
</code></pre>
<p>The KeepAliveBroadcaster class maintains a list of connected sessions.
Using a
<a href="http://msdn.microsoft.com/en-us/library/system.threading.timer.aspx">Timer</a>
it sends a message to each client every 15 seconds. This should stop the
connection from dropping due to an idle timeout.</p>
<pre><code>public class KeepAliveBroadcaster {

    private List&lt;WebSocketsService&gt; _services;

    private Timer _timer;

 

    public KeepAliveBroadcaster() {

        _timer = new Timer((o) =&gt; {

            if (_services == null) {

                return;

            }

            lock (_services) {

                if (_services.Count &gt; 0) {

                    foreach (var service in _services) {

                        service.Send(&quot;staying alive!&quot;);

                    }

                }

            }

        }, null, 100, 15000);              

    }

 

    public void AddService(WebSocketsService service) {

        if (_services == null) {

            _services = new List&lt;WebSocketsService&gt;();

        }

        lock (_services) {               

            _services.Add(service);

        }

    }

 

    public void RemoveService(WebSocketsService service) {

        lock (_services) {

            _services.Remove(service);

        }

    }

}
</code></pre>
<p><strong>Reopening ASAP</strong></p>
<p>Something you could also implement is reopening the connection as soon
as it closes.</p>
<p>Retry opening the connection when the onclose event fires. Think about
limiting the number of retries, or you might end up with an infinite
loop.</p>
<pre><code>websocket.onclose = function (event) {            

    $('#status').html('Socket closed');    

    

    retryOpeningWebSocket();

};

 

function retryOpeningWebSocket(){

    if (retries &lt; 2) {            

        setTimeout(openWebSocket, 1000);            

        retries++;

    }

}
</code></pre>
<p><strong>Some afterthought</strong></p>
<p>Depending on what type of connectivity you require, these solutions
might not suffice. If you can&rsquo;t afford to lose a single message, you
might want to think about implementing queues at the client and server
to overcome a gap of connection loss. Maybe you even want to implement
some sort of acknowledge messaging. Something for a future post maybe!</p>
<p><strong>Start experimenting yourself?</strong></p>
<p>These links might get you started:</p>
<ul>
<li><a href="http://jclaes.blogspot.com/2011/01/html5-installing-microsoft-websockets.html">Installing the Microsoft WebSockets
prototype</a></li>
<li><a href="http://jclaes.blogspot.com/2011/01/html5-rebuilding-websockets-server.html">Rebuilding the WebSockets Server
prototype</a></li>
<li><a href="http://jclaes.blogspot.com/2011/01/html5-websockets-prototype-with.html">The WebSockets prototype with Silverlight, HTML Bridges and
JavaScript</a></li>
</ul>

			</div>

			<div class="tags">
				
					
						<ul class="flat">
							
							<li><a href="/tags/microsoft">Microsoft</a></li>
							
							<li><a href="/tags/browsers">Browsers</a></li>
							
							<li><a href="/tags/hack">Hack</a></li>
							
							<li><a href="/tags/html5">HTML5</a></li>
							
						</ul>
					
				
			</div></div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div>2011  <a href="https://github.com/knadh/hugo-ink">Ink</a> theme on <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>

<script>feather.replace()</script>
</body>
</html>
